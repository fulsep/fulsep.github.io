"use strict";(self.webpackChunkdocusaurus_blog=self.webpackChunkdocusaurus_blog||[]).push([[4984],{9471:(a,n,e)=>{e.r(n),e.d(n,{assets:()=>p,contentTitle:()=>d,default:()=>c,frontMatter:()=>l,metadata:()=>u,toc:()=>s});var t=e(7462),o=(e(7294),e(3905)),i=e(8607);e(9960);const l={slug:"perbedaan-lifecycle-react-pada-class-component-dan-functional-component",title:"React Lifecycle: Class Component vs Functional Component",authors:["irul"],tags:["Frontend Development","Beginner Frontend","ReactJS"],date:"2021-05-06T11:00"},d=void 0,u={permalink:"/perbedaan-lifecycle-react-pada-class-component-dan-functional-component",source:"@site/blog/2023-01-21-002-perbedaan-lifecycle-react-pada-class-component-dan-functional-component.mdx",title:"React Lifecycle: Class Component vs Functional Component",description:"",date:"2021-05-06T11:00:00.000Z",formattedDate:"6 Mei 2021",tags:[{label:"Frontend Development",permalink:"/tags/frontend-development"},{label:"Beginner Frontend",permalink:"/tags/beginner-frontend"},{label:"ReactJS",permalink:"/tags/react-js"}],readingTime:2.775,hasTruncateMarker:!0,authors:[{name:"Irul",title:"JavaScript Enthusiast",url:"https://github.com/fulsep",imageURL:"https://github.com/fulsep.png",key:"irul"}],frontMatter:{slug:"perbedaan-lifecycle-react-pada-class-component-dan-functional-component",title:"React Lifecycle: Class Component vs Functional Component",authors:["irul"],tags:["Frontend Development","Beginner Frontend","ReactJS"],date:"2021-05-06T11:00"},prevItem:{title:"Upload file dengan ReactJS dan axios",permalink:"/upload-file-dengan-reactjs-dan-axios"},nextItem:{title:"Apa itu State pada React Component?",permalink:"/apa-itu-state-pada-react-component"}},p={authorsImageUrls:[void 0]},s=[{value:"Perbedaan utama",id:"perbedaan-utama",level:2},{value:"Dependensi pada useEffect",id:"dependensi-pada-useeffect",level:2},{value:"Kesimpulan",id:"kesimpulan",level:2}],m={toc:s};function c(a){let{components:n,...e}=a;return(0,o.kt)("wrapper",(0,t.Z)({},m,e,{components:n,mdxType:"MDXLayout"}),(0,o.kt)(i.Z,{src:"/img/blog/react.png",alt:"react",mdxType:"ImageCenterize"}),(0,o.kt)("p",null,"Kita terkadang bingung dengan cara kerja dari perenderan komponen pada class component dan functional component, akan tetapi jika kita telaah lebih jauh ternyata perbedaannya hanya pada penggunaan lifecycle nya saja."),(0,o.kt)("h2",{id:"perbedaan-utama"},"Perbedaan utama"),(0,o.kt)("p",null,"Perbedaan utama antara lifecycle pada class component dan functional component menggunakan hooks adalah bahwa class component menggunakan metode lifecycle seperti componentDidMount, componentDidUpdate, dan componentWillUnmount, sementara functional component menggunakan hooks seperti useEffect untuk menangani masalah yang sama. Namun, dengan hooks, kita dapat menulis kode yang lebih terstruktur dan terlihat lebih sederhana."),(0,o.kt)("p",null,"Di bawah ini adalah contoh perbedaan antara lifecycle pada class component dan functional component menggunakan hooks:"),(0,o.kt)("p",null,"Pada Class Component:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"class Example extends React.Component {\n  componentDidMount() {\n    // kode untuk menjalankan saat component telah di-mount\n  }\n  \n  componentDidUpdate(prevProps, prevState) {\n    // kode untuk menjalankan saat component telah di-update\n  }\n  \n  componentWillUnmount() {\n    // kode untuk menjalankan saat component akan di-unmount\n  }\n  \n  render() {\n    return <div>Example</div>;\n  }\n}\n")),(0,o.kt)("p",null,"Pada Functional Component + Hooks:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function Example() {\n  useEffect(() => {\n    // kode untuk menjalankan saat component telah di-mount\n    // atau setelah component di-update\n    return () => {\n      // kode untuk menjalankan saat component akan di-unmount\n    }\n  }, []);\n  \n  return <div>Example</div>;\n}\n")),(0,o.kt)("p",null,"Pada functional component dengan hooks, kita dapat menggunakan useEffect untuk menjalankan kode saat component di-mount dan di-update, serta mengembalikan sebuah fungsi untuk menjalankan kode saat component di-unmount. Sedangkan pada class component kita menggunakan metode lifecycle yang berbeda untuk menjalankan kode pada saat yang berbeda."),(0,o.kt)("h2",{id:"dependensi-pada-useeffect"},"Dependensi pada useEffect"),(0,o.kt)("p",null,"Jika kita perhatikan, pada parameter kedua useEffect setelah callback pada contoh diatas, ada array kosong, itulah yang kita sebut sebagai Dependensi pada useEffect."),(0,o.kt)("p",null,"Dependensi pada useEffect adalah sebuah daftar yang berisi variabel yang digunakan dalam efek itu. Setiap kali nilai variabel tersebut berubah, React akan memanggil efek itu kembali. Jika Anda tidak menyertakan daftar dependensi, React akan memanggil efek itu setiap kali component di-render."),(0,o.kt)("p",null,"Contoh:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const [count, setCount] = useState(0);\n\nuseEffect(() => {\n  console.log(`Count: ${count}`);\n}, [count]);\n")),(0,o.kt)("p",null,"Dalam contoh di atas, efek akan dijalankan setiap kali nilai dari variabel count berubah. Karena dependensi hanya menyertakan count, React tidak akan memanggil efek itu kembali jika hanya mengubah state lain."),(0,o.kt)("p",null,"Dependensi juga dapat digunakan untuk mengawasi perubahan pada props."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function Component({id}) {\n  useEffect(() => {\n    fetchData(id);\n  }, [id]);\n  return <div>Data: {data}</div>;\n}\n")),(0,o.kt)("p",null,"Kode di atas akan memanggil fetchData saat id berubah. Jika tidak menyertakan dependensi, fetchData akan dipanggil setiap kali component di-render."),(0,o.kt)("p",null,"Jika tidak ingin mengawasi perubahan pada suatu variabel, bisa menyertakan dependensi dengan nilai kosong."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'useEffect(() => {\n  console.log("Component did mount");\n}, []);\n')),(0,o.kt)("p",null,"Kode di atas akan menjalankan efek hanya saat component di-mount."),(0,o.kt)("h2",{id:"kesimpulan"},"Kesimpulan"),(0,o.kt)("p",null,"Kesimpulannya, React menyediakan metode lifecycle pada class component dan hooks pada functional component untuk menangani peristiwa seperti mount, update, dan unmount. Class component menggunakan metode lifecycle seperti componentDidMount, componentDidUpdate, dan componentWillUnmount. Sedangkan functional component menggunakan hooks seperti useEffect untuk menangani masalah yang sama."),(0,o.kt)("p",null,"useEffect sendiri adalah hook yang digunakan untuk menjalankan kode saat component di-mount dan di-update, serta mengembalikan sebuah fungsi untuk menjalankan kode saat component di-unmount. Dependensi pada useEffect adalah sebuah daftar yang berisi variabel yang digunakan dalam efek itu, setiap kali nilai variabel tersebut berubah, React akan memanggil efek itu kembali. Dengan menggunakan dependensi, kita dapat mengontrol kapan efek itu dijalankan dan menghindari efek yang tidak diinginkan."),(0,o.kt)("p",null,"Semoga Bermanfaat!"))}c.isMDXComponent=!0}}]);